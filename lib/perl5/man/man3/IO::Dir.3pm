.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "IO::Dir 3"
.TH IO::Dir 3 "perl v5.16.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Dir \- supply object methods for directory handles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use IO::Dir;
\&    $d = IO::Dir\->new(".");
\&    if (defined $d) {
\&        while (defined($_ = $d\->read)) { something($_); }
\&        $d\->rewind;
\&        while (defined($_ = $d\->read)) { something_else($_); }
\&        undef $d;
\&    }
\&
\&    tie %dir, \*(AqIO::Dir\*(Aq, ".";
\&    foreach (keys %dir) {
\&        print $_, " " , $dir{$_}\->size,"\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`IO::Dir\*(C'\fR package provides two interfaces to perl's directory reading
routines.
.PP
The first interface is an object approach. \f(CW\*(C`IO::Dir\*(C'\fR provides an object
constructor and methods, which are just wrappers around perl's built in
directory reading routines.
.IP "new ( [ \s-1DIRNAME\s0 ] )" 4
.IX Item "new ( [ DIRNAME ] )"
\&\f(CW\*(C`new\*(C'\fR is the constructor for \f(CW\*(C`IO::Dir\*(C'\fR objects. It accepts one optional
argument which,  if given, \f(CW\*(C`new\*(C'\fR will pass to \f(CW\*(C`open\*(C'\fR
.PP
The following methods are wrappers for the directory related functions built
into perl (the trailing 'dir' has been removed from the names). See perlfunc
for details of these functions.
.IP "open ( \s-1DIRNAME\s0 )" 4
.IX Item "open ( DIRNAME )"
.PD 0
.IP "read ()" 4
.IX Item "read ()"
.IP "seek ( \s-1POS\s0 )" 4
.IX Item "seek ( POS )"
.IP "tell ()" 4
.IX Item "tell ()"
.IP "rewind ()" 4
.IX Item "rewind ()"
.IP "close ()" 4
.IX Item "close ()"
.PD
.PP
\&\f(CW\*(C`IO::Dir\*(C'\fR also provides an interface to reading directories via a tied
hash. The tied hash extends the interface beyond just the directory
reading routines by the use of \f(CW\*(C`lstat\*(C'\fR, from the \f(CW\*(C`File::stat\*(C'\fR package,
\&\f(CW\*(C`unlink\*(C'\fR, \f(CW\*(C`rmdir\*(C'\fR and \f(CW\*(C`utime\*(C'\fR.
.ie n .IP "tie %hash, 'IO::Dir', \s-1DIRNAME\s0 [, \s-1OPTIONS\s0 ]" 4
.el .IP "tie \f(CW%hash\fR, 'IO::Dir', \s-1DIRNAME\s0 [, \s-1OPTIONS\s0 ]" 4
.IX Item "tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]"
.PP
The keys of the hash will be the names of the entries in the directory. 
Reading a value from the hash will be the result of calling
\&\f(CW\*(C`File::stat::lstat\*(C'\fR.  Deleting an element from the hash will 
delete the corresponding file or subdirectory,
provided that \f(CW\*(C`DIR_UNLINK\*(C'\fR is included in the \f(CW\*(C`OPTIONS\*(C'\fR.
.PP
Assigning to an entry in the hash will cause the time stamps of the file
to be modified. If the file does not exist then it will be created. Assigning
a single integer to a hash element will cause both the access and 
modification times to be changed to that value. Alternatively a reference to
an array of two values can be passed. The first array element will be used to
set the access time and the second element will be used to set the modification
time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::stat
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perlbug@perl.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2003 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
