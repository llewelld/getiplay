.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Mojo::Exception 3"
.TH Mojo::Exception 3 "perl v5.16.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Exception \- Exception base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  # Create exception classes
\&  package MyApp::X::Foo {
\&    use Mojo::Base \*(AqMojo::Exception\*(Aq;
\&  }
\&  package MyApp::X::Bar {
\&    use Mojo::Base \*(AqMojo::Exception\*(Aq;
\&  }
\&
\&  # Throw exceptions and handle them gracefully
\&  use Mojo::Exception \*(Aqcheck\*(Aq;
\&  eval {
\&    MyApp::X::Foo\->throw(\*(AqSomething went wrong!\*(Aq);
\&  };
\&  check(
\&    \*(AqMyApp::X::Foo\*(Aq => sub { say "Foo: $_" },
\&    \*(AqMyApp::X::Bar\*(Aq => sub { say "Bar: $_" }
\&  );
\&
\&  # Generate exception classes on demand
\&  use Mojo::Exception qw(check raise);
\&  eval {
\&    raise \*(AqMyApp::X::Name\*(Aq, \*(AqThe name Minion is already taken\*(Aq;
\&  };
\&  check(
\&    \*(AqMyApp::X::Name\*(Aq => sub { say "Name error: $_" },
\&    default          => sub { say "Error: $_" }
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Exception is a container for exceptions with context information.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Mojo::Exception implements the following functions, which can be imported
individually.
.SS "check"
.IX Subsection "check"
.Vb 2
\&  my $bool = check \*(AqMyApp::X::Foo\*(Aq => sub {...};
\&  my $bool = check $err, \*(AqMyApp::X::Foo\*(Aq => sub {...};
.Ve
.PP
Process exceptions by dispatching them to handlers with one or more matching
conditions. Exceptions that could not be handled will be rethrown automatically.
By default \f(CW$@\fR will be used as exception source, so \f(CW\*(C`check\*(C'\fR needs to be
called right after \f(CW\*(C`eval\*(C'\fR. Note that this function is \fB\s-1EXPERIMENTAL\s0\fR and might
change without warning!
.PP
.Vb 10
\&  # Handle various types of exceptions
\&  eval {
\&    dangerous_code();
\&  };
\&  check(
\&    \*(AqMyApp::X::Foo\*(Aq     => sub { say "Foo: $_" },
\&    qr/^Could not open/ => sub { say "Open error: $_" },
\&    default             => sub { say "Something went wrong: $_" },
\&    finally             => sub { say \*(AqDangerous code is done\*(Aq }
\&  );
.Ve
.PP
Matching conditions can be class names for \s-1ISA\s0 checks on exception objects, or
regular expressions to match string exceptions and stringified exception
objects. The matching exception will be the first argument passed to the
callback, and is also available as \f(CW$_\fR.
.PP
.Vb 8
\&  # Catch MyApp::X::Foo object or a specific string exception
\&  eval {
\&    dangerous_code();
\&  };
\&  check(
\&    \*(AqMyApp::X::Foo\*(Aq     => sub { say "Foo: $_" },
\&    qr/^Could not open/ => sub { say "Open error: $_" }
\&  );
.Ve
.PP
An array reference can be used to share the same handler with multiple
conditions, of which only one needs to match. And since exception handlers are
just callbacks, they can also throw their own exceptions.
.PP
.Vb 7
\&  # Handle MyApp::X::Foo and MyApp::X::Bar the same
\&  eval {
\&    dangerous_code();
\&  };
\&  check(
\&    [\*(AqMyApp::X::Foo\*(Aq, \*(AqMyApp::X::Bar\*(Aq] => sub { die "Foo/Bar: $_" }
\&  );
.Ve
.PP
There are currently two keywords you can use to set special handlers. The
\&\f(CW\*(C`default\*(C'\fR handler is used when no other handler matched. And the \f(CW\*(C`finally\*(C'\fR
handler runs always, it does not affect normal handlers and even runs if the
exception was rethrown or if there was no exception to be handled at all.
.PP
.Vb 8
\&  # Use "default" to catch everything
\&  eval {
\&    dangerous_code();
\&  };
\&  check(
\&    default => sub { say "Error: $_" },
\&    finally => sub { say \*(AqDangerous code is done\*(Aq }
\&  );
.Ve
.SS "raise"
.IX Subsection "raise"
.Vb 2
\&  raise \*(AqSomething went wrong!\*(Aq;
\&  raise \*(AqMyApp::X::Foo\*(Aq, \*(AqSomething went wrong!\*(Aq;
.Ve
.PP
Raise a Mojo::Exception, if the class does not exist yet (classes are checked
for a \f(CW\*(C`new\*(C'\fR method), one is created as a Mojo::Exception subclass on demand.
Note that this function is \fB\s-1EXPERIMENTAL\s0\fR and might change without warning!
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::Exception implements the following attributes.
.SS "frames"
.IX Subsection "frames"
.Vb 2
\&  my $frames = $e\->frames;
\&  $e         = $e\->frames([$frame1, $frame2]);
.Ve
.PP
Stack trace if available.
.PP
.Vb 3
\&  # Extract information from the last frame
\&  my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext,
\&      $is_require, $hints, $bitmask, $hinthash) = @{$e\->frames\->[\-1]};
.Ve
.SS "line"
.IX Subsection "line"
.Vb 2
\&  my $line = $e\->line;
\&  $e       = $e\->line([3, \*(Aqdie;\*(Aq]);
.Ve
.PP
The line where the exception occurred if available.
.SS "lines_after"
.IX Subsection "lines_after"
.Vb 2
\&  my $lines = $e\->lines_after;
\&  $e        = $e\->lines_after([[4, \*(Aqsay $foo;\*(Aq], [5, \*(Aqsay $bar;\*(Aq]]);
.Ve
.PP
Lines after the line where the exception occurred if available.
.SS "lines_before"
.IX Subsection "lines_before"
.Vb 2
\&  my $lines = $e\->lines_before;
\&  $e        = $e\->lines_before([[1, \*(Aqmy $foo = 23;\*(Aq], [2, \*(Aqmy $bar = 24;\*(Aq]]);
.Ve
.PP
Lines before the line where the exception occurred if available.
.SS "message"
.IX Subsection "message"
.Vb 2
\&  my $msg = $e\->message;
\&  $e      = $e\->message(\*(AqDied at test.pl line 3.\*(Aq);
.Ve
.PP
Exception message, defaults to \f(CW\*(C`Exception!\*(C'\fR.
.SS "verbose"
.IX Subsection "verbose"
.Vb 2
\&  my $bool = $e\->verbose;
\&  $e       = $e\->verbose($bool);
.Ve
.PP
Show more information with \*(L"to_string\*(R", such as \*(L"frames\*(R", defaults to
the value of the \f(CW\*(C`MOJO_EXCEPTION_VERBOSE\*(C'\fR environment variable.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Exception inherits all methods from Mojo::Base and implements the
following new ones.
.SS "inspect"
.IX Subsection "inspect"
.Vb 2
\&  $e = $e\->inspect;
\&  $e = $e\->inspect($source1, $source2);
.Ve
.PP
Inspect \*(L"message\*(R", \*(L"frames\*(R" and optional additional sources to fill
\&\*(L"lines_before\*(R", \*(L"line\*(R" and \*(L"lines_after\*(R" with context information.
.SS "new"
.IX Subsection "new"
.Vb 2
\&  my $e = Mojo::Exception\->new;
\&  my $e = Mojo::Exception\->new(\*(AqDied at test.pl line 3.\*(Aq);
.Ve
.PP
Construct a new Mojo::Exception object and assign \*(L"message\*(R" if necessary.
.SS "to_string"
.IX Subsection "to_string"
.Vb 1
\&  my $str = $e\->to_string;
.Ve
.PP
Render exception. Note that the output format may change as more features are
added, only the error message at the beginning is guaranteed not to be modified
to allow regex matching.
.SS "throw"
.IX Subsection "throw"
.Vb 1
\&  Mojo::Exception\->throw(\*(AqSomething went wrong!\*(Aq);
.Ve
.PP
Throw exception from the current execution context.
.PP
.Vb 2
\&  # Longer version
\&  die Mojo::Exception\->new(\*(AqSomething went wrong!\*(Aq)\->trace;
.Ve
.SS "trace"
.IX Subsection "trace"
.Vb 2
\&  $e = $e\->trace;
\&  $e = $e\->trace($skip);
.Ve
.PP
Generate stack trace and store all \*(L"frames\*(R", defaults to skipping \f(CW1\fR call
frame.
.PP
.Vb 2
\&  # Skip 3 call frames
\&  $e\->trace(3);
\&
\&  # Skip no call frames
\&  $e\->trace(0);
.Ve
.SH "OPERATORS"
.IX Header "OPERATORS"
Mojo::Exception overloads the following operators.
.SS "bool"
.IX Subsection "bool"
.Vb 1
\&  my $bool = !!$e;
.Ve
.PP
Always true.
.SS "stringify"
.IX Subsection "stringify"
.Vb 1
\&  my $str = "$e";
.Ve
.PP
Alias for \*(L"to_string\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <https://mojolicious.org>.
